#!/usr/bin/env python
"""
Script to create the request_logs table in Supabase.

This script creates the request_logs table in Supabase for token usage tracking.
If the table already exists, it will inform the user without trying to recreate it.
"""

import argparse
import logging
import os
import sys
from typing import Optional

import dotenv
from supabase import Client, create_client
from supabase.lib.client_options import ClientOptions

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("vt.ai.setup")

# Load environment variables
dotenv.load_dotenv()


def get_supabase_client() -> Optional[Client]:
    """
    Initialize the Supabase client using environment variables.

    Returns:
        Initialized Supabase client or None if initialization fails
    """
    supabase_url = os.environ.get("SUPABASE_URL")
    supabase_key = os.environ.get("SUPABASE_SERVICE_KEY") or os.environ.get(
        "SUPABASE_KEY"
    )

    if not supabase_url or not supabase_key:
        logger.error(
            "SUPABASE_URL and SUPABASE_SERVICE_KEY (or SUPABASE_KEY) must be set in environment variables."
        )
        return None

    try:
        # Initialize with service key to have admin privileges
        client = create_client(supabase_url, supabase_key)
        logger.info("Supabase client initialized successfully.")
        return client
    except Exception as e:
        logger.error(f"Failed to initialize Supabase client: {e}")
        return None


def check_table_exists(supabase: Client, table_name: str) -> bool:
    """
    Check if a table exists in the database.

    Args:
        supabase: Initialized Supabase client
        table_name: Name of the table to check

    Returns:
        True if the table exists, False otherwise
    """
    try:
        # Query the information_schema to check if the table exists
        response = (
            supabase.table("information_schema.tables")
            .select("table_name")
            .eq("table_schema", "public")
            .eq("table_name", table_name)
            .execute()
        )

        return len(response.data) > 0
    except Exception as e:
        logger.error(f"Error checking if table {table_name} exists: {e}")
        return False


def create_request_logs_table(supabase: Client) -> bool:
    """
    Create the request_logs table in Supabase.

    Args:
        supabase: Initialized Supabase client

    Returns:
        True if the table was created successfully, False otherwise
    """
    # Check if the table already exists
    if check_table_exists(supabase, "request_logs"):
        logger.info("request_logs table already exists. Skipping creation.")
        return True

    # SQL statement to create the request_logs table
    create_table_sql = """
    CREATE TABLE IF NOT EXISTS public.request_logs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY,
        created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
        model TEXT NULL DEFAULT ''::TEXT,
        messages JSONB NULL DEFAULT '{}'::JSONB,
        response JSONB NULL DEFAULT '{}'::JSONB,
        end_user TEXT NULL DEFAULT ''::TEXT,
        status TEXT NULL DEFAULT ''::TEXT,
        error JSONB NULL DEFAULT '{}'::JSONB,
        response_time REAL NULL DEFAULT '0'::REAL,
        total_cost REAL NULL,
        additional_details JSONB NULL DEFAULT '{}'::JSONB,
        litellm_call_id TEXT UNIQUE,
        PRIMARY KEY (id)
    );

    -- Enable RLS on request_logs table
    ALTER TABLE public.request_logs ENABLE ROW LEVEL SECURITY;

    -- Create policy for users to view their own request logs
    CREATE POLICY "Users can view their own request logs"
    ON public.request_logs
    FOR SELECT
    USING (auth.uid()::TEXT = end_user OR (auth.role() = 'service_role'));

    -- Create policy for inserting request logs
    CREATE POLICY "Users can insert their own request logs"
    ON public.request_logs
    FOR INSERT
    WITH CHECK (auth.uid()::TEXT = end_user OR end_user IS NULL OR auth.role() = 'service_role');

    -- Create policy for anon insert
    CREATE POLICY "Anonymous users can insert request logs"
    ON public.request_logs
    FOR INSERT
    WITH CHECK (end_user IS NULL OR auth.role() = 'anon');
    """

    # Legacy table if it doesn't exist yet
    create_legacy_table_sql = """
    CREATE TABLE IF NOT EXISTS public.usage_logs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY,
        created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
        user_id TEXT NULL DEFAULT ''::TEXT,
        session_id TEXT NULL DEFAULT ''::TEXT,
        model_name TEXT NULL DEFAULT ''::TEXT,
        input_tokens INTEGER NULL DEFAULT 0,
        output_tokens INTEGER NULL DEFAULT 0,
        total_tokens INTEGER NULL DEFAULT 0,
        cost REAL NULL DEFAULT 0,
        auth_method TEXT NULL DEFAULT 'supabase'::TEXT,
        PRIMARY KEY (id)
    );

    -- Enable RLS on usage_logs table
    ALTER TABLE public.usage_logs ENABLE ROW LEVEL SECURITY;

    -- Create policy for users to view their own usage logs
    CREATE POLICY "Users can view their own usage logs"
    ON public.usage_logs
    FOR SELECT
    USING (auth.uid()::TEXT = user_id OR (auth.role() = 'service_role'));

    -- Create policy for inserting usage logs
    CREATE POLICY "Users can insert their own usage logs"
    ON public.usage_logs
    FOR INSERT
    WITH CHECK (auth.uid()::TEXT = user_id OR user_id IS NULL OR auth.role() = 'service_role');

    -- Create policy for anon insert
    CREATE POLICY "Anonymous users can insert usage logs"
    ON public.usage_logs
    FOR INSERT
    WITH CHECK (user_id IS NULL OR auth.role() = 'anon');
    """

    # Create trigger for migration between tables
    create_trigger_sql = """
    -- Create function to migrate from usage_logs to request_logs
    CREATE OR REPLACE FUNCTION public.migrate_usage_log_to_request_log()
    RETURNS TRIGGER AS $$
    BEGIN
        INSERT INTO public.request_logs (
            model,
            messages,
            end_user,
            status,
            response_time,
            total_cost,
            additional_details,
            litellm_call_id
        )
        VALUES (
            NEW.model_name,
            '[]'::JSONB,
            NEW.user_id,
            'success',
            0,
            NEW.cost,
            jsonb_build_object(
                'session_id', NEW.session_id,
                'input_tokens', NEW.input_tokens,
                'output_tokens', NEW.output_tokens,
                'total_tokens', NEW.total_tokens,
                'auth_method', NEW.auth_method,
                'migrated_from_usage_logs', TRUE,
                'migrated_at', NOW(),
                'usage_log_id', NEW.id
            ),
            CONCAT('usage-log-', NEW.id)
        );
        RETURN NEW;
    EXCEPTION
        WHEN unique_violation THEN
            -- Skip the insert if there's a conflict with litellm_call_id
            RETURN NEW;
        WHEN OTHERS THEN
            -- Log other errors but don't fail the trigger
            RETURN NEW;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Create trigger if it doesn't exist
    DROP TRIGGER IF EXISTS usage_logs_to_request_logs_trigger ON public.usage_logs;
    CREATE TRIGGER usage_logs_to_request_logs_trigger
    AFTER INSERT ON public.usage_logs
    FOR EACH ROW
    EXECUTE FUNCTION public.migrate_usage_log_to_request_log();
    """

    try:
        # Execute the SQL statements
        logger.info("Creating request_logs table...")
        supabase.query(create_table_sql).execute()

        # Create legacy table if needed
        if not check_table_exists(supabase, "usage_logs"):
            logger.info("Creating usage_logs table...")
            supabase.query(create_legacy_table_sql).execute()

        # Create trigger for migration
        logger.info("Creating migration trigger...")
        supabase.query(create_trigger_sql).execute()

        logger.info("Successfully created request_logs table and related objects.")
        return True
    except Exception as e:
        logger.error(f"Error creating request_logs table: {e}")
        return False


def display_sql_for_manual_execution():
    """Display the SQL statements for manual execution in the Supabase SQL Editor."""
    sql_statements = """
-- Create request_logs table
CREATE TABLE IF NOT EXISTS public.request_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
    model TEXT NULL DEFAULT ''::TEXT,
    messages JSONB NULL DEFAULT '{}'::JSONB,
    response JSONB NULL DEFAULT '{}'::JSONB,
    end_user TEXT NULL DEFAULT ''::TEXT,
    status TEXT NULL DEFAULT ''::TEXT,
    error JSONB NULL DEFAULT '{}'::JSONB,
    response_time REAL NULL DEFAULT '0'::REAL,
    total_cost REAL NULL,
    additional_details JSONB NULL DEFAULT '{}'::JSONB,
    litellm_call_id TEXT UNIQUE,
    PRIMARY KEY (id)
);

-- Enable RLS on request_logs table
ALTER TABLE public.request_logs ENABLE ROW LEVEL SECURITY;

-- Create policy for users to view their own request logs
CREATE POLICY "Users can view their own request logs"
ON public.request_logs
FOR SELECT
USING (auth.uid()::TEXT = end_user OR (auth.role() = 'service_role'));

-- Create policy for inserting request logs
CREATE POLICY "Users can insert their own request logs"
ON public.request_logs
FOR INSERT
WITH CHECK (auth.uid()::TEXT = end_user OR end_user IS NULL OR auth.role() = 'service_role');

-- Create policy for anon insert
CREATE POLICY "Anonymous users can insert request logs"
ON public.request_logs
FOR INSERT
WITH CHECK (end_user IS NULL OR auth.role() = 'anon');

-- Create usage_logs table for backward compatibility
CREATE TABLE IF NOT EXISTS public.usage_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
    user_id TEXT NULL DEFAULT ''::TEXT,
    session_id TEXT NULL DEFAULT ''::TEXT,
    model_name TEXT NULL DEFAULT ''::TEXT,
    input_tokens INTEGER NULL DEFAULT 0,
    output_tokens INTEGER NULL DEFAULT 0,
    total_tokens INTEGER NULL DEFAULT 0,
    cost REAL NULL DEFAULT 0,
    auth_method TEXT NULL DEFAULT 'supabase'::TEXT,
    PRIMARY KEY (id)
);

-- Enable RLS on usage_logs table
ALTER TABLE public.usage_logs ENABLE ROW LEVEL SECURITY;

-- Create policy for users to view their own usage logs
CREATE POLICY "Users can view their own usage logs"
ON public.usage_logs
FOR SELECT
USING (auth.uid()::TEXT = user_id OR (auth.role() = 'service_role'));

-- Create policy for inserting usage logs
CREATE POLICY "Users can insert their own usage logs"
ON public.usage_logs
FOR INSERT
WITH CHECK (auth.uid()::TEXT = user_id OR user_id IS NULL OR auth.role() = 'service_role');

-- Create policy for anon insert
CREATE POLICY "Anonymous users can insert usage logs"
ON public.usage_logs
FOR INSERT
WITH CHECK (user_id IS NULL OR auth.role() = 'anon');

-- Create function to migrate from usage_logs to request_logs
CREATE OR REPLACE FUNCTION public.migrate_usage_log_to_request_log()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.request_logs (
        model,
        messages,
        end_user,
        status,
        response_time,
        total_cost,
        additional_details,
        litellm_call_id
    )
    VALUES (
        NEW.model_name,
        '[]'::JSONB,
        NEW.user_id,
        'success',
        0,
        NEW.cost,
        jsonb_build_object(
            'session_id', NEW.session_id,
            'input_tokens', NEW.input_tokens,
            'output_tokens', NEW.output_tokens,
            'total_tokens', NEW.total_tokens,
            'auth_method', NEW.auth_method,
            'migrated_from_usage_logs', TRUE,
            'migrated_at', NOW(),
            'usage_log_id', NEW.id
        ),
        CONCAT('usage-log-', NEW.id)
    );
    RETURN NEW;
EXCEPTION
    WHEN unique_violation THEN
        -- Skip the insert if there's a conflict with litellm_call_id
        RETURN NEW;
    WHEN OTHERS THEN
        -- Log other errors but don't fail the trigger
        RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger
DROP TRIGGER IF EXISTS usage_logs_to_request_logs_trigger ON public.usage_logs;
CREATE TRIGGER usage_logs_to_request_logs_trigger
AFTER INSERT ON public.usage_logs
FOR EACH ROW
EXECUTE FUNCTION public.migrate_usage_log_to_request_log();
"""

    print("\n" + "=" * 80)
    print("SQL STATEMENTS TO EXECUTE IN SUPABASE SQL EDITOR")
    print("=" * 80)
    print(sql_statements)
    print("=" * 80)
    print(
        "\nCopy the SQL statements above and execute them in the Supabase SQL Editor."
    )
    print(
        "Go to your Supabase project > SQL Editor > New Query > Paste the statements > Run"
    )


def main():
    """Main function to handle command line arguments and execute the script."""
    parser = argparse.ArgumentParser(
        description="Create the request_logs table in Supabase for token usage tracking."
    )
    parser.add_argument(
        "--manual",
        action="store_true",
        help="Display SQL for manual execution instead of creating the table automatically.",
    )

    args = parser.parse_args()

    if args.manual:
        display_sql_for_manual_execution()
        return 0

    # Get Supabase client
    supabase = get_supabase_client()
    if not supabase:
        logger.error("Failed to initialize Supabase client. Exiting.")
        return 1

    # Create the request_logs table
    if create_request_logs_table(supabase):
        logger.info("Setup completed successfully.")
        return 0
    else:
        logger.error("Setup failed.")
        return 1


if __name__ == "__main__":
    sys.exit(main())
