# Token Usage Tracking with LiteLLM and Supabase

## Overview

This document explains how token usage tracking is implemented in VT.ai using LiteLLM callbacks and Supabase.

## Components

### 1. Database Tables

Two tables are used for token usage tracking:

- **request_logs**: The main table for storing detailed request information
- **usage_logs**: A legacy table maintained for backward compatibility

### 2. Callback Handler

The `VTAISupabaseHandler` class is a custom implementation that provides user identification and enhanced logging capabilities for token usage tracking. It's designed to work directly with Supabase without relying on LiteLLM's built-in handlers.

### 3. Initialization

The callback handler is initialized in `vtai/utils/config.py` during application startup.

## How It Works

1. When an LLM request is made using LiteLLM, the callbacks are triggered.
2. The `log_success_event` method is called for successful requests.
3. The `log_failure_event` method is called for failed requests.
4. Both methods retrieve user information from the Chainlit session.
5. Request data is logged to both the `request_logs` and `usage_logs` tables.

## Database Schema

### request_logs Table

```sql
CREATE TABLE public.request_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
    model TEXT NULL DEFAULT ''::TEXT,
    messages JSONB NULL DEFAULT '{}'::JSONB,
    response JSONB NULL DEFAULT '{}'::JSONB,
    end_user TEXT NULL DEFAULT ''::TEXT,
    status TEXT NULL DEFAULT ''::TEXT,
    error JSONB NULL DEFAULT '{}'::JSONB,
    response_time REAL NULL DEFAULT '0'::REAL,
    total_cost REAL NULL,
    additional_details JSONB NULL DEFAULT '{}'::JSONB,
    litellm_call_id TEXT UNIQUE,
    PRIMARY KEY (id)
);
```

### usage_logs Table

```sql
CREATE TABLE public.usage_logs (
    id UUID NOT NULL DEFAULT uuid_generate_v4(),
    user_id TEXT NOT NULL,
    session_id TEXT NULL DEFAULT ''::TEXT,
    model_name TEXT NULL DEFAULT ''::TEXT,
    input_tokens INTEGER NULL DEFAULT '0'::INTEGER,
    output_tokens INTEGER NULL DEFAULT '0'::INTEGER,
    total_tokens INTEGER NULL DEFAULT '0'::INTEGER,
    cost REAL NULL DEFAULT '0'::REAL,
    created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
    auth_method TEXT NULL DEFAULT 'supabase'::TEXT,
    PRIMARY KEY (id)
);
```

## Troubleshooting

### Common Issues

1. **Table Permissions**: The most common issue is related to Row-Level Security (RLS) policies. The token tracking system needs appropriate RLS policies to allow insertions into the tables.

2. **Callback Registration**: Check that the callbacks are properly registered with LiteLLM. Look for log messages saying "Successfully initialized LiteLLM callbacks".

3. **401 Unauthorized Errors**: If you see 401 errors, it's likely that the RLS policies are preventing the insertions. Use the service key instead of the regular key to bypass RLS.

4. **Missing Tables**: Ensure both the `request_logs` and `usage_logs` tables exist in your Supabase database.

5. **"can't be used in 'await' expression" Errors**: This occurs when the Supabase client's response object is incorrectly awaited. The fix is to use the Supabase client in a non-awaitable manner, since the Python SDK already returns the result synchronously when execute() is called.

### API Response Handling

If you see errors like "object APIResponse[~_ReturnT] can't be used in 'await' expression", it indicates a mismatch in how the Supabase client is being used. The Supabase Python SDK's methods should be used without awaiting the execute() call:

```python
# Incorrect usage - this will cause errors:
result = await client.table("request_logs").insert(log_entry).execute()

# Correct usage - do not await the execute() method:
query = client.table("request_logs").insert(log_entry)
result = query.execute()
```

### Diagnostic Steps

1. **Test Direct Insertion**:

   We've created a diagnostic script `scripts/test_direct_insertion.py` that bypasses LiteLLM callbacks and tests direct insertion into the tables. This helps isolate whether the issue is with the database configuration or the callback mechanism.

   ```bash
   python scripts/test_direct_insertion.py
   ```

2. **Use Service Key**:

   For diagnostic purposes, use the Supabase service key instead of the regular key:

   ```bash
   python scripts/test_enhanced_litellm_callbacks.py --service-key
   ```

3. **Check Callback Execution**:

   We've enhanced the logging in the callback handler. Look for log messages like "LiteLLM success callback triggered" to confirm that callbacks are being executed.

4. **Verify Table Structure**:

   Check that the tables have the correct structure using the Supabase Table Editor.

### RLS Policy Updates

If you need to fix permissions, run these SQL commands in the Supabase SQL Editor:

```sql
-- For request_logs table
-- Create permissive insert policy
CREATE POLICY "Allow all inserts to request_logs"
ON public.request_logs
FOR INSERT WITH CHECK (true);

-- Create policy for service role to do anything
CREATE POLICY "Service role has full access to request_logs"
ON public.request_logs
USING (auth.role() = 'service_role');

-- For usage_logs table
-- Create permissive insert policy
CREATE POLICY "Allow all inserts to usage_logs"
ON public.usage_logs
FOR INSERT WITH CHECK (true);

-- Create policy for service role to do anything
CREATE POLICY "Service role has full access to usage_logs"
ON public.usage_logs
USING (auth.role() = 'service_role');
```

## Testing

Use these scripts for testing the token tracking system:

1. `scripts/test_enhanced_litellm_callbacks.py`: Test the entire callback flow
2. `scripts/test_direct_insertion.py`: Test direct insertion into Supabase tables

## Manual Logging

If the automatic callback mechanism fails, you can use the `log_usage_to_supabase` function to manually log token usage:

```python
from vtai.utils.litellm_callbacks import log_usage_to_supabase

await log_usage_to_supabase(
    user_id="user-123",
    session_id="session-456",
    model_name="gpt-3.5-turbo",
    input_tokens=100,
    output_tokens=50,
    total_tokens=150
)
```

### usage_logs Table

```sql
CREATE TABLE public.usage_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
    user_id TEXT NULL DEFAULT ''::TEXT,
    session_id TEXT NULL DEFAULT ''::TEXT,
    model_name TEXT NULL DEFAULT ''::TEXT,
    input_tokens INTEGER NULL DEFAULT 0,
    output_tokens INTEGER NULL DEFAULT 0,
    total_tokens INTEGER NULL DEFAULT 0,
    cost REAL NULL DEFAULT 0,
    auth_method TEXT NULL DEFAULT 'supabase'::TEXT,
    PRIMARY KEY (id)
);
```

## Row-Level Security

Row-Level Security (RLS) policies are applied to both tables to ensure users can only access their own data.

## Setup

1. Run the table creation script:

```bash
python scripts/create_request_logs_table.py
```

Or manually execute the SQL in the Supabase SQL Editor:

```bash
python scripts/create_request_logs_table.py --manual
```

2. Test the callbacks:

```bash
python scripts/test_litellm_callbacks.py
```

## Usage in Code

### Automatic Logging

Token usage is automatically logged when using LiteLLM for API calls:

```python
from litellm import completion

response = completion(
    model="openrouter/qwen/qwen3-0.6b-04-28:free",
    messages=[{"role": "user", "content": "Hello, how are you?"}],
    user="user-123",  # User ID for tracking
)
```

### Manual Logging

For cases where automatic logging fails or for custom scenarios:

```python
from vtai.utils.litellm_callbacks import log_usage_to_supabase

await log_usage_to_supabase(
    user_id="user-123",
    session_id="session-123",
    model_name="openrouter/qwen/qwen3-0.6b-04-28:free",
    input_tokens=10,
    output_tokens=20,
    total_tokens=30,
    cost=0.0001,
)
```

## Subscription Tier Management

Token usage data is used to enforce subscription tier limits. The limits are defined in `vtai/main.py`:

```python
# Define tier-based token limits
tier_limits = {
    "free": 10000,      # 10k tokens for free tier
    "basic": 100000,    # 100k tokens for basic tier
    "premium": 500000,  # 500k tokens for premium tier
    "unlimited": float("inf"),  # No limit for unlimited tier
}
```

## Troubleshooting

### Common Issues

1. **Missing Token Usage Records**
   - Ensure the Supabase client is properly initialized
   - Verify that LiteLLM callbacks are registered
   - Check if user ID is being correctly extracted from the session
   - Verify that the tables exist in your Supabase database
   - Ensure your application has proper permissions to insert data

2. **Duplicate Records**
   - Expected behavior when `log_to_legacy` is set to `True`
   - Set `log_to_legacy=False` to avoid duplicate logging

3. **Permission Errors**
   - Confirm that RLS policies are correctly applied
   - Ensure users are authenticated properly
   - **Use the service key:** For token logging, use `SUPABASE_SERVICE_KEY` instead of `SUPABASE_KEY`
   - Run the `update_token_tracking_policies.py` script to update RLS policies

4. **Callback Not Working**
   - Different versions of LiteLLM may have different callback mechanisms
   - Try registering callbacks directly with the handler instances instead of string identifiers
   - Check for any exceptions during the callback execution
   - Verify row-level security policies allow inserts from your application

### Debugging Token Tracking

To debug token tracking issues, use the enhanced test script:

```bash
# Test with regular key (might fail due to permission issues)
python scripts/test_enhanced_litellm_callbacks.py

# Test with service key (recommended for token tracking)
python scripts/test_enhanced_litellm_callbacks.py --service-key
```

If the test fails with permission errors, update your RLS policies:

```bash
python scripts/update_token_tracking_policies.py
```

### Handling 401 Unauthorized Errors

The token tracking implementation includes robust error handling for 401 Unauthorized errors. When these occur:

1. The error is captured and logged with a helpful message
2. The application continues to function without interruption
3. A suggestion to use the service key is provided in the logs

To fix 401 errors, either:

- Update your RLS policies using the `update_token_tracking_policies.py` script
- Use the Supabase service key in your application configuration

## Implementation Details

### Callback Handler

The custom `VTAISupabaseHandler` class is implemented in `vtai/utils/litellm_callbacks.py`. It handles:

1. **User identification**: Extracts user IDs from various contexts (Chainlit sessions, request metadata)
2. **Token estimation**: Provides approximate token counts when not available in the API response
3. **Dual table logging**: Records usage data to both modern and legacy tables
4. **Error handling**: Captures and logs failure events with detailed error information

Unlike the built-in LiteLLM handlers, our implementation is standalone and doesn't depend on specific LiteLLM integration classes, making it more robust to LiteLLM version changes.

```python
# Example of our callback handler registration
callback_handler = VTAISupabaseHandler(
    supabase_client=supabase_client,
    table_name="request_logs",
    log_to_legacy=True
)

# Register with LiteLLM - works with various versions
litellm.callbacks = [callback_handler]
if hasattr(litellm, "success_callback"):
    litellm.success_callback = [callback_handler]
if hasattr(litellm, "failure_callback"):
    litellm.failure_callback = [callback_handler]
```
